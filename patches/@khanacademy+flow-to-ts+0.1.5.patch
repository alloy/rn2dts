diff --git a/node_modules/@khanacademy/flow-to-ts/babel-generator/lib/printer.js b/node_modules/@khanacademy/flow-to-ts/babel-generator/lib/printer.js
index 7383d6d..a2e18ab 100644
--- a/node_modules/@khanacademy/flow-to-ts/babel-generator/lib/printer.js
+++ b/node_modules/@khanacademy/flow-to-ts/babel-generator/lib/printer.js
@@ -313,7 +313,7 @@ class Printer {
 
     let needsParens = n.needsParens(node, parent, this._printStack);
 
-    if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
+    if (this.format.retainFunctionParens && (node.type === "TSFunctionType" || (node.type === "FunctionExpression" && node.extra && node.extra.parenthesized))) {
       needsParens = true;
     }
 
diff --git a/node_modules/@khanacademy/flow-to-ts/src/convert.js b/node_modules/@khanacademy/flow-to-ts/src/convert.js
index dc9c67c..2d609cc 100644
--- a/node_modules/@khanacademy/flow-to-ts/src/convert.js
+++ b/node_modules/@khanacademy/flow-to-ts/src/convert.js
@@ -46,7 +46,7 @@ const convert = (flowCode, options) => {
 
   // we pass flowCode so that generate can compute source maps
   // if we ever decide to
-  let tsCode = generate(ast, flowCode).code;
+  let tsCode = generate(ast, { retainFunctionParens: true }, flowCode).code;
   for (let i = 0; i < state.trailingLines; i++) {
     tsCode += "\n";
   }
diff --git a/node_modules/@khanacademy/flow-to-ts/src/transform.js b/node_modules/@khanacademy/flow-to-ts/src/transform.js
index 8ab9470..688cb75 100644
--- a/node_modules/@khanacademy/flow-to-ts/src/transform.js
+++ b/node_modules/@khanacademy/flow-to-ts/src/transform.js
@@ -1,4 +1,3 @@
-const path = require("path");
 const t = require("@babel/types");
 
 const computeNewlines = require("./compute-newlines.js");
@@ -412,6 +411,20 @@ const transform = {
             typeParameters
           )
         );
+      } else if (typeName.name === "Object") {
+        path.replaceWith(t.tsAnyKeyword());
+      } else if (typeName.name === "Function") {
+        const functionType = t.tsFunctionType(
+          null,
+          [{
+            type: "RestElement",
+            argument: t.identifier("args"),
+            decorators: null,
+            typeAnnotation: t.tsTypeAnnotation(t.tsAnyKeyword()),
+          }],
+          t.tsTypeAnnotation(t.tsAnyKeyword())
+        );
+        path.replaceWith(functionType);
       } else {
         path.replaceWith(t.tsTypeReference(typeName, typeParameters));
       }
@@ -435,6 +448,18 @@ const transform = {
       }
     }
   },
+  ClassProperty: {
+    exit(path) {
+      const { variance } = path.node;
+      const readonly = variance && variance.kind === "plus";
+      if (variance && variance.kind === "minus") {
+        // TODO: include file and location of infraction
+        console.warn("typescript doesn't support writeonly properties");
+      }
+      delete path.node.variance;
+      path.node.readonly = readonly;
+    }
+  },
   ObjectTypeProperty: {
     exit(path) {
       const { key, value, optional, variance, kind, method } = path.node; // TODO: static, kind
@@ -566,6 +591,14 @@ const transform = {
       }
     }
   },
+  // TODO: Should this be replaced with a nominal type?
+  OpaqueType: {
+    exit(path) {
+      const { id, impltype, typeParameters } = path.node;
+
+      path.replaceWith(t.tsTypeAliasDeclaration(id, typeParameters, impltype));
+    }
+  },
   TypeAlias: {
     exit(path) {
       const { id, typeParameters, right } = path.node;
